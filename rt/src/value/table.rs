use std::cell::{BorrowError, BorrowMutError, Ref, RefCell, RefMut};
use std::collections::HashMap;
use std::fmt::Debug;
use std::hash::Hash;
use std::rc::Rc;

use ordered_float::NotNan;

use super::callable::Callable;
use super::Value;

pub struct Table<C> {
    data: HashMap<KeyValue<C>, Value<C>>,
    metatable: Option<TableRef<C>>,
}

impl<C> Table<C> {
    pub fn get(&self, key: KeyValue<C>) -> Value<C> {
        self.data.get(&key).cloned().unwrap_or_default()
    }

    pub fn set(&mut self, key: KeyValue<C>, value: Value<C>) {
        if value == Value::Nil {
            self.data.remove(&key);
        } else {
            self.data.insert(key, value);
        }
    }

    pub fn contains_key(&self, key: &KeyValue<C>) -> bool {
        self.data.contains_key(key)
    }

    pub fn border(&self) -> i64 {
        // Inefficient, but will get fixed when table layout is improved.
        (0..)
            .find(|&i| !self.data.contains_key(&KeyValue::Int(i + 1)))
            .unwrap_or(i64::MAX)
    }

    pub fn metatable(&self) -> Option<TableRef<C>> {
        self.metatable.clone()
    }

    pub fn set_metatable(&mut self, mut metatable: Option<TableRef<C>>) -> Option<TableRef<C>> {
        std::mem::swap(&mut self.metatable, &mut metatable);
        metatable
    }
}

impl<C> Debug for Table<C> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Table").field("data", &self.data).finish()
    }
}

impl<C> Clone for Table<C> {
    fn clone(&self) -> Self {
        Self {
            data: self.data.clone(),
            metatable: self.metatable.clone(),
        }
    }
}

impl<C> PartialEq for Table<C> {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}

impl<C> Default for Table<C> {
    fn default() -> Self {
        Self {
            data: Default::default(),
            metatable: Default::default(),
        }
    }
}

pub enum KeyValue<C> {
    Bool(bool),
    Int(i64),
    Float(NotNan<f64>),
    String(String),
    Function(Callable<C>),
    Table(TableRef<C>),
}

impl<C> Debug for KeyValue<C> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Bool(arg0) => f.debug_tuple("Bool").field(arg0).finish(),
            Self::Int(arg0) => f.debug_tuple("Int").field(arg0).finish(),
            Self::Float(arg0) => f.debug_tuple("Float").field(arg0).finish(),
            Self::String(arg0) => f.debug_tuple("String").field(arg0).finish(),
            Self::Function(arg0) => f.debug_tuple("Function").field(arg0).finish(),
            Self::Table(arg0) => f.debug_tuple("Table").field(arg0).finish(),
        }
    }
}

// Autogenerated, keep it around until garbage collector.
#[allow(clippy::clone_on_copy)]
impl<C> Clone for KeyValue<C> {
    fn clone(&self) -> Self {
        match self {
            Self::Bool(arg0) => Self::Bool(arg0.clone()),
            Self::Int(arg0) => Self::Int(arg0.clone()),
            Self::Float(arg0) => Self::Float(arg0.clone()),
            Self::String(arg0) => Self::String(arg0.clone()),
            Self::Function(arg0) => Self::Function(arg0.clone()),
            Self::Table(arg0) => Self::Table(arg0.clone()),
        }
    }
}

impl<C> PartialEq for KeyValue<C> {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::Bool(l0), Self::Bool(r0)) => l0 == r0,
            (Self::Int(l0), Self::Int(r0)) => l0 == r0,
            (Self::Float(l0), Self::Float(r0)) => l0 == r0,
            (Self::String(l0), Self::String(r0)) => l0 == r0,
            (Self::Function(l0), Self::Function(r0)) => l0 == r0,
            (Self::Table(l0), Self::Table(r0)) => l0 == r0,
            _ => false,
        }
    }
}

impl<C> Eq for KeyValue<C> {}

impl<C> Hash for KeyValue<C> {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        core::mem::discriminant(self).hash(state);

        match self {
            Self::Bool(t) => t.hash(state),
            Self::Int(t) => t.hash(state),
            Self::Float(t) => t.hash(state),
            Self::String(t) => t.hash(state),
            Self::Function(t) => t.hash(state),
            Self::Table(t) => t.hash(state),
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub enum InvalidTableKeyError {
    Nil,
    Nan,
}

impl InvalidTableKeyError {
    pub(crate) fn value_str(self) -> &'static str {
        match self {
            InvalidTableKeyError::Nan => "NaN",
            InvalidTableKeyError::Nil => "nil",
        }
    }
}

impl<C> TryFrom<Value<C>> for KeyValue<C> {
    type Error = InvalidTableKeyError;

    fn try_from(value: Value<C>) -> Result<Self, Self::Error> {
        let r = match value {
            Value::Bool(t) => KeyValue::Bool(t),
            Value::Int(t) => KeyValue::Int(t),
            Value::Float(t) => {
                let t = NotNan::new(t).map_err(|_| InvalidTableKeyError::Nan)?;
                KeyValue::Float(t)
            }
            Value::String(t) => KeyValue::String(t),
            Value::Function(t) => KeyValue::Function(t),
            Value::Table(t) => KeyValue::Table(t),
            Value::Nil => return Err(InvalidTableKeyError::Nil),
        };

        Ok(r)
    }
}

impl<C> From<KeyValue<C>> for Value<C> {
    fn from(value: KeyValue<C>) -> Self {
        match value {
            KeyValue::Bool(t) => Value::Bool(t),
            KeyValue::Int(t) => Value::Int(t),
            KeyValue::Float(t) => Value::Float(t.into_inner()),
            KeyValue::Function(t) => Value::Function(t),
            KeyValue::String(t) => Value::String(t),
            KeyValue::Table(t) => Value::Table(t),
        }
    }
}

pub struct TableRef<C>(Rc<RefCell<Table<C>>>);

impl<C> TableRef<C> {
    pub fn new() -> Self {
        Default::default()
    }

    pub fn borrow(&self) -> Result<Ref<Table<C>>, BorrowError> {
        self.0.try_borrow()
    }

    pub fn borrow_mut(&self) -> Result<RefMut<Table<C>>, BorrowMutError> {
        self.0.try_borrow_mut()
    }
}

impl<C> Debug for TableRef<C> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("TableRef").field(&self.0).finish()
    }
}

impl<C> Clone for TableRef<C> {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}

impl<C> Default for TableRef<C> {
    fn default() -> Self {
        Self(Default::default())
    }
}

impl<C> PartialEq for TableRef<C> {
    fn eq(&self, other: &Self) -> bool {
        Rc::ptr_eq(&self.0, &other.0)
    }
}

impl<C> Eq for TableRef<C> {}

impl<C> Hash for TableRef<C> {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        Rc::as_ptr(&self.0).hash(state)
    }
}

impl<C> From<Table<C>> for TableRef<C> {
    fn from(value: Table<C>) -> Self {
        TableRef(Rc::new(RefCell::new(value)))
    }
}
